<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="abstract">Abstract</h1>
<p>This report is intended to give a general overview of bash, Markdown, Git, Github, Pandoc, GNU Make. The ultimate goal is to expose you to the general process of creating a reproducible project and perhaps help you avoid the difficulties I encountered. In this report, I will:</p>
<ul>
<li>give an overview of each computational tool I used, including its function and basic usage.</li>
<li>discuss how I used these tools in this specific project.</li>
<li>explore in what ways I found these tools easy or hard to use.</li>
<li>describe my experience making this report i.e. how long it took, what I fond eary or hard about it, and what resources I used to help me along the way.</li>
</ul>
<hr />
<h1 id="introduction">Introduction</h1>
<p>Hello there! This project's purpose is to help teach about some basic computational tools by explaining how I made this project itself. The tools in question include bash, Markdown, Git, Github, GNU Make, and Pandoc. I will give an overview of each of these tools, explain how I used them to create this project, and detail my experience, describing parts of the process I found easy/frustrating/quick/slow/etc.</p>
<p>This can be used as reference material for those who are already somewhat experienced in making reproducible projects. However, it can also serve as a tutorial for the less experienced. This project is quite simple, and its file structure is basic, so it can also be seen as a template to expand upon and alter in order to create more complex projects. Enjoy!</p>
<hr />
<p><img src="https://raw.githubusercontent.com/acarango/stat159_fall2016_proj1/master/images/stat159-logo.png" /> #Discussion</p>
<h3 id="bash">1. bash</h3>
<p>To make this project, I had to begin by creating a file structure to work in. For this I used bash, which is a Unix shell and command language. This 'shell' is essentially an interface which allows me to interact with the 'kernel' which does the actual computing. Through the terminal on my laptop I used some basic bash commands to create the file structure for the project (shown below).</p>
<pre><code>stat159-fall2016-project1/
    .gitignore
    README.md
    Makefile
    paper/
        sections/
            00-abstract.md
            01-introduction.md
            02-discussion.md
            03-conclusions.md
        paper.md
        paper.html
    images/
        git-logo.png
        github-logo.png
        markdown-logo.png
        pandoc-logo.png
        stat159-logo.png</code></pre>
<p>I started by creating all the directories. This was accomplished using the <code>mkdir</code> command. Typing <code>mkdir</code> followed by a directory name of your choice creates a directory.</p>
<p>It was essential to be able to move between directories in order to create subdirectories and edit files within these subdirectories. The <code>cd</code> command allows us to do this.<code>cd</code> alone puts you in your home directory. <code>cd dir</code> moves you into a subdirectory.<code>cd ..</code> moves you up a directory. You can also use relative and absolute paths with <code>cd</code>. There are more tricky ways to use <code>cd</code>, but the above commands are all you really need to get the job done.</p>
<p>Once the directories were all sorted out, I used the command <code>touch FILE...</code> to create all of the text files. Then, I used nano to edit all the text files, including all markdown files, the readme, the makefile and the gitignore. The bash command <code>nano FILE...</code> causes nano to boot up and lets you begin editing the text file. After editing, use <code>^O</code> to save the content and then <code>^X</code> to exit nano.</p>
<p>In my opinion, nano is useful because it is easy to call up through bash. It works just fine for short bits of text, such as this project's Makefile (which I will discuss later). However I found it poor for writing long segments of text, so for the essay itself I used MacDown and simply copied into nano when I wanted to save changes.</p>
<p>Moving, deleting, and concatenating files also proved useful for this project. The syntax for these are:</p>
<pre><code>rm [OPTION]... FILE...

mv [options] source dest

cat FILES... &gt; FILE...</code></pre>
<p>The first two commands came into play when I made errors such as creating a file in the wrong directory or accidently creating a superfluous file. <code>mv</code> was especially useful for moving the image files which I downloaded from the class GutHub repository into my project file structure. <code>mv</code> and <code>cat</code> came into use in my makefile, but we will consider that later.</p>
<p>With the above commands I was able to create the file structure for this project. Although it took some quick and relearning of commands I forgot, I was able to complete this step within two hours without requiring help.</p>
<h3 id="markdown">2. Markdown</h3>
<div class="figure">
<img src="https://raw.githubusercontent.com/acarango/stat159_fall2016_proj1/master/images/markdown-logo.png" />

</div>
<p>For writing the essay itself I used Markdown, which is a lightweight markup language. Markdown has a very simple syntax, and Markdown documents can be created easily in any basic text editor. Essentially, Markdown is a very easy tool for creating good looking documents that can be converted to many formats.</p>
<p>Some useful syntax that came into play in this project include:</p>
<ul>
<li>Placing a <code>#</code> before a phrase will make it a header. Adding more poundsigns (up to six) makes the header smaller.</li>
<li>Using <code>***</code> in its own line creates horizontal rules.</li>
<li>Using <code>*</code> makes bullet points for lists just like this one!</li>
<li><code>![](url)</code> adds the photo from the given url to the document.</li>
<li>Surrounding text in `` changes it into inline code.</li>
</ul>
<p>These five pieces of Markdown syntax were all I really needed to write this essay, although there is more syntax that can come into use for more computational and data-centered work. Markdown proved to be very easy to use on this project, and it seems to me this is exactly what the creators intended. Afterall, it is called a &quot;lightweight&quot; markup language because it is user friendly. Moreover the program MacDown made it even easier for me, because of its great user-interface. With a text editor on the left, and a visualisation of what the rendered document would look like on the right, I was able to correct mistakes easily. Whenever I wanted to edit the text files within the project I copied the text from MacDown into nano. The process of writing took the most time of all, but I would say it was the smoothest part of the project, and formatting via Markdown was extremely quick and easy.</p>
<h3 id="git-and-github">3. Git and GitHub</h3>
<p><img src="https://raw.githubusercontent.com/acarango/stat159_fall2016_proj1/master/images/git-logo.png" /> <img src="https://raw.githubusercontent.com/acarango/stat159_fall2016_proj1/master/images/github-logo.png" /></p>
<p>Git and Github came into play during the writing process mainly as a way of saving edits safeley and with the option of reverting to older versions. I'd like to talk about them at the same time because they were used in tandem during the making of this project.</p>
<p>Git is a type of version control software. This means git helps us keep track of the changes we make in a project. Git allows us to start with an original document, then save individual changes we make to the document during the development process. With Git, one can easily cycle through past incarnations of a document and choose which edits to keep and which to discard. When used correctly, this prevents people from losing important parts of their work. It also makes finding older versions of files less stressful.</p>
<p>Using Git locally works fine when someone is working alone. However, when collaboration comes into the picture, using a remote repository on the web becomes necessary. GitHub is a hosting service created specifically for Git which allows groups of contributors to work on remote repositories. GitHub users can connect a local repository to a GitHub repository. Once this is done they can &quot;push&quot; content from their local repository to GitHub and &quot;pull&quot; content from GitHub to their local repository.</p>
<p>Let's go through how I used Git and GitHub on this project:</p>
<ul>
<li>First of all I had to get Git running in the root directory of my project. This was accomplished with the bash command <code>git init</code>.</li>
<li>Then I created a GitHub repository with the same name as my project's root directory <code>stat159_fall2016_proj1</code>. You need to set up an account before doing this if you don't already have one.</li>
<li>To connect the remote repository to my local repository I used the commands <code>git remote add origin url</code> <code>git remote -v</code> and <code>git push -u origin master</code>. Once these commands are executed the local and remote repositories are connected.</li>
<li>When I wanted to make an edit on a file, for example adding another section to one of the Markdown files, I would do so locally then use the commands <code>git add FILE...</code> <code>git commit -m &quot;message&quot;</code> and <code>git push</code> in sequence.</li>
<li>If interested in looking at my history of commits, I used <code>git log</code> which shows the project history. <code>git status</code> was useful for checking if I had made an error during the process of committing and pushing an edit.</li>
</ul>
<p>I encountered difficulty connecting my local and remote repositories for this project, having never used Git before. I made an error connecting the repositories which caused there to be a readme file in the remote repository but not in the local repository. When attempting my first commit, I was presented with an error. After seeking help from the class GSI, I learned that the simple remedy to pull from the remote repository. After this I had no issues using Git and it proved quite easy to use.</p>
<h3 id="gnu-make-and-pandoc">5. GNU Make and Pandoc</h3>
<div class="figure">
<img src="https://raw.githubusercontent.com/acarango/stat159_fall2016_proj1/master/images/pandoc-logo.png" />

</div>
<p>Once I was satisfied with the essay, it was time to &quot;glue everything together&quot; so to speak and create a final product. I accomplished this by using GNU Make and Pandoc in tandem. GNU Make is a piece of software known as a build automation tool, which automates the process of creating non-source material from source material. Essentially, Make lets us define our own command <code>make</code> through a textfile called <code>Makefile</code>. The <code>make</code> command can do many different things depending on what we put in the makefile, but the goal in this project was to concatenate the sections of the essay together and then convert to html. Pandoc is a program that can convert documents between a wide array of formats, so I used it in my makefile in order to convert from markdown to html.</p>
<p>Here is what the contents of my makefile look like:</p>
<pre><code>.PHONY: all clean

all: paper.md paper.html

paper.md: paper/sections/*.md
        cd paper/sections; cat *.md &gt; paper.md
        cd paper/sections; mv paper.md ../

paper.html: paper/paper.md
        cd paper; pandoc paper.md -s -o paper.html

clean:
        cd paper; rm -f paper.html paper.md</code></pre>
<p><code>paper.md</code> and <code>paper.html</code> are called file targets, and <code>paper/sections/*.md</code> and <code>paper/paper.md</code> are called dependencies. A file target is the file to be made and a dependency is an already existing file or group of files that will be used to make the target. Below the target and dependencies are bash commands that will create the target file. Notice that I had to use paths to define my dependecies and I had to use <code>cd</code> within the commands. This is because the makefile was in the root directory and the dependencies were located in subdirectories. Also, notice that I used the wildcard <code>*</code> to select all the .md files in the sections directory rather than name each file individually.</p>
<p>In addition to file targets we have the special target <code>.PHONY</code> as well as two phony targets <code>all</code> and <code>clean</code>, which unlike the default targets are not associated with files. <code>.PHONY</code> is simply used to distinguish a target as phony. There are many applications for phony targets, but in this project I used them for very basic functions. <code>all</code> has the two file targets as dependencies. This means when we run <code>make</code> it runs both target programs. The <code>make</code> command automatically runs the first target's program only, so if we want to run any other targets program we must add the target's name after <code>make</code>. The target <code>clean</code> has no dependencies and simply deletes <code>paper.html</code> and <code>paper.md</code>. Remember to use <code>make clean</code> if you want to do this, since the first target in the makefile is <code>all</code>.</p>
<p>As for Pandoc, its usage in this project is very simple. I used the command <code>pandoc paper.md -s -o paper.html</code> The option <code>-s</code> gives us a standalone output, and the <code>-o</code> option gives us a file as an output. You can see that the first file in the command is the file to be converted and the second is the file with a new extension of our choice. Pandoc will recognize this and convert the file to the correct format.</p>
<p>Learning the basics of Make was, to me, the most conceptually challenging part of creating this project. Specifically, it was difficult for me to conceptuallize targets and dependencies. The fact that the makefile for this project is very simple alleviated much of my confusion however. It only took me about an hour to grasp Make in the context of this project and feel confident in its usage.</p>
<hr />
<h1 id="conclusions">Conclusions</h1>
<p>All in all, this project took me about 12 hours to complete over the course of 4 days. About half this time was spent writing and the other half setting up the file structure, creating the makefile, and formatting. Little help was required trhoughout this process. I consulted the class GSI once for help regarding Git, but other than that I worked completely independently. The hardest parts of this project included coding the makefile correctly and learning how to use Git and GitHub smoothly. The eastiest parts included using Pandoc and writing in Markown. In conclusion here are the most important lessons I learned working on this project.</p>
<ul>
<li>It is important to have a file structure in place, have Git initialized, and be connected to GitHub before getting into the &quot;meat&quot; of the project.</li>
<li>Commiting to Git often is very helpful and (although I did not encounter this situation) prevents loss of content that sometimes happens without automated version control.</li>
<li>Using a text editor such as MacDown, which has a good looking interface, prevents mistakes in Markdown and it is easy to copy into nano to make edits.</li>
<li>Pandoc can convert to essentially any document format, so you can always start with a simple markdown file without worrying about what format the final product will be in.</li>
<li>Make sure to have bash commands memorized well in order to avoid having to waste time looking up commands.</li>
<li>Automating the creation of the creation of the final document via Make is worth doing. In more complex projects where people may want to verify conclusions or substitute data it is important to make workflow easily reproducible, and Make does this exactly.</li>
</ul>
</body>
</html>
